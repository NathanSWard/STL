// barrier standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _BARRIER_
#define _BARRIER_
#include <yvals_core.h>
#if _STL_COMPILER_PREPROCESSOR

#if !_HAS_CXX20
#pragma message("The contents of <barrier> are available only with C++20 or later.")
#else // ^^^ !_HAS_CXX20 / _HAS_CXX20 vvv
#include <atomic>
#include <limits>

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN

struct _Deafult_barrier_completion_func {
    constexpr void operator()() const noexcept {}
};

template <class _CompletionFunc = _Deafult_barrier_completion_func>
class barrier {
public:
    using arrival_token = bool;

    static constexpr ptrdiff_t max() noexcept {
        return numeric_limits<ptrdiff_t>::max();
    }

    constexpr explicit barrier(const ptrdiff_t _Expected, _CompletionFunc _Completion = _CompletionFunc())
        : _Completion(_STD move(_Completion)), _Expected(_Expected), _Arrived(_Expected) {}

    ~barrier() = default;

    barrier(const barrier&) = delete;
    barrier& operator=(const barrier&) = delete;

    _NODISCARD arrival_token arrive(const ptrdiff_t _Decrement = 1) {
        const bool _This_phase         = _Phase.load(memory_order_relaxed);
        const ptrdiff_t _Remaining     = _Arrived.fetch_sub(_Decrement, memory_order_acq_rel) - _Decrement;
        const ptrdiff_t _This_expected = _Expected.load(memory_order_relaxed);
        if (_Remaining == 0) {
            _Completion();
            _Arrived.store(_This_expected, memory_order_relaxed);
            _Phase.store(!_This_phase, memory_order_release);
            _Phase.notify_all();
        }
        return _This_phase;
    }

    void wait(arrival_token&& _Token) const {
        _Phase.wait(_Token, memory_order_acquire);
    }

    void arrive_and_wait() {
        wait(arrive());
    }

    void arrive_and_drop() {
        _Expected.fetch_sub(1, memory_order_relaxed);
        static_cast<void>(arrive());
    }

private:
    [[no_unique_address]] _CompletionFunc _Completion;
    atomic<ptrdiff_t> _Expected;
    atomic<ptrdiff_t> _Arrived;
    atomic<bool> _Phase{false};
};

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _HAS_CXX20
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _BARRIER_
